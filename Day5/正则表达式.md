# 正则表达式
正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的<br>
## 如何用字符来描述字符
* 直接给出字符就是精确匹配<br>
  例如：'1'只能匹配‘1’
* 用一些特定的字符来表示一类字符<br>
  例如：‘/d’可以匹配数字，‘/w’可以匹配数字与字母，‘.’可以匹配任意字符。那么，‘00/d’就可以匹配‘001’，‘002’等
* 对匹配长度的控制<br>
  '*'，表示匹配任意数量<br>
  '+'，表示至少一个<br>
  '?'，表示0或1个<br>
  '{n}',表示n个
  '{n,m}',表示n到m个
  ```
   \d{3}\s+\d{3,8}。
  从左到右解读：
  \d{3}表示匹配3个数字，例如'010'；
  \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；
  \d{3,8}表示3-8个数字，例如'1234567'。
  ```
* 对匹配内容的精确控制
  * '[]',表示可以匹配的范围<br>
  例如：[0-9a-zA-Z]匹配一个数字大写或小写字母<br>
        [0-9a-zA-Z\_]匹配数字字母下划线<br>
        [a-zA-Z][0-9a-zA-Z]* 由字母开头，后面接任意个数字或字母
  * ‘|’，或<br>
    A|B，匹配A或B
  * '^',表示行的开头。'$'表示行的结尾
    
## re模块
使用python的r前缀，不用考虑Python字符串转义的问题
```
s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变：
# 'ABC\-001'
```
### 判断正则表达式是否匹配
match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：
```
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
```
### 切分字符串
```
>>> re.split(r'\s+', 'a b   c')    #r'\s+',表示至少一个空格
['a', 'b', 'c']
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')   #r'[\s\,\;]+'，表示至少一个空格，逗号，或分号
['a', 'b', 'c', 'd']
```
### 分组
正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。
```
>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')    
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'
```
^(\d{3})-(\d{3,8})$分别定义了两个组,group(0)永远表示原字符串，group(1)表示提取到的第一组子串
### 贪婪匹配
贪婪匹配：尽可能多地匹配，在匹配过程中发现当前已匹配，还会继续检查后续的字符串，如果后续结果匹配，会更新匹配结果
非贪婪匹配：尽可能少地匹配，一旦已经匹配了就不会再检查后续的
例子：
```
import re
s = '<html><head><title>Title</title>'
m = re.match(r'(<.*>)',s)
print(m.group(0))     #<html><head><title>Title</title>
m = re.match(r'(<.*?>)',s)
print(m.group(0))     #<html>
```
RE 在 "<html>" 中 匹配 "<"，.* 会消耗掉字符串的剩余部分。RE 中保持更多的向左匹配， 不能在字符串结尾匹配“>”，因此正则表达式必须一个字符一个字符地回溯，直到它找到 > 的匹配。最终的匹配从 "<html" 中的 "<" 到 "</title>" 中的 ">",这变成了全文匹配，并不是你想要的结果。
在这种情况下，解决方案是使用不贪婪的限定符 *?、+?、?? 或 {m,n}?，尽可能匹配小的文本。在上面的例子里，在第一个 "<" 之后立即尝试匹配 ">"，当它失败时，引擎一次增加一个字符，并在每步重试 匹配">"。这个处理将得到正确的结果：

### 编译
每次遇到正则表达式就会编译一次，如果相同的表达式用到多次，则提前进行编译会提高效率
```
import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```
