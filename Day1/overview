输入输出：
	格式化输出：print()
		print('%d%s',%(d,s),end = '') #print自带换行\n

	输入：input('写在前面')
		a = int(input())    #只能从屏幕上输入数字（0～9）
		a = float(input())  

数据类型
	整型 int ：Python中可以处理任意大小的整数
			int(x,base = 10) base表示参数x采用的进制，可用于N进制转10进制
	浮点型 float ：浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）
	字符串型 str：字符串是以单引号或双引号括起来的任意文本
	布尔型 bool：布尔值只有True、False两种值
	复数型 complex：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。

命名规则：
	语法规定：
	    大小写敏感
	    数字字母下划线
	    不能与关键字冲突

	PEP 8要求：
	    用小写字母拼写，多个单词用下划线连接。
	    受保护的实例属性用单个下划线开头。
	    私有的实例属性用两个下划线开头。

	通常习惯采用驼峰命名法，私有成员变量单个下划线开头。

注释：
	# 单行以#开头
 	"""多行用三引号框起来"""

冒号(：)的作用:
	出现在函数定义语句、if、else、elif、 for、 while语句末尾表示之后代码为一个代码块
	出现在字典定义当中用于分开键和值
	出现在列表中用于定义分片、步长
	出现在numpy数组中
	    1.默认全部选择：X[:,0]就是取矩阵X的所有行的第0列的元素，X[:,1] 就是取所有行的第1列的元素
	    2.指定范围，含左不含右：X[:, m:n]即取矩阵X的所有行中的的第m到n-1列数据，含左不含右

帮助：
	python中所有东西都是对象，包括各种数据类型，函数
	dir(对象) 查看对象的所有属性与方法
	help(对象/模块.方法) 查看具体函数的用法 	

import：
	1.使用import语句将一个源代码文件作为模块导入
		import a.py
		系统在导入模块时，要做以下三件事： 
			a.为源代码文件中定义的对象创建一个名字空间，通过这个名字空间可以访问到模块中定义的函数及变量。
			b.在新创建的名字空间里执行源代码文件
			c.创建一个名为源代码文件的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量
			  执行了上面的import，就创建了对象a
	2.用逗号分割模块名称就可以同时导入多个模块: 
		import socket, os, regex
	3.模块导入时可以使用 as 关键字来改变模块的引用对象名字
		import os as system
		system.chdir("..")
	4.使用from语句可以将模块中的对象直接导入到当前的名字空间. 
	  from语句不创建一个到模块名字空间的引用对象，而是把被导入模块的一个或多个对象直接放入当前的名字空间
	  	from socket import gethostname   #不创建socket对象，直接在当前作用域创建gethostname对象
		gethostname()                    #因为在当前的作用域，所以可以直接调用
	5.from语句支持逗号分割的对象，也可以使用星号(*)代表模块中除下划线开头的所有对象: 
		from socket import *
	  如果该模块定义过列表__all__，则from module import * 语句只能导入__all__列表中存在的对象
	  	__all__ = [ 'f1', 'f2' ]     # 定义使用 `*` 可以导入的对象，只能用f1，f2
	[注]	import 语句可以在程序的任何位置使用，你可以在程序中多次导入同一个模块，但模块中的代码*仅仅*在该模块被首次导入时执行。
	     后面的import语句只是简单的创建一个到模块名字空间的引用而已。
	 6.import模块搜索路径
	 	当你导入一个模块，Python 解析器对模块位置的搜索顺序是：
			1、当前目录
			2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。
			3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。
		模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。
	 7.修改搜索路径
		1.直接修改sys.path，添加要搜索的目录：
			import sys
			sys.path.append('/Users/michael/my_py_scripts')
		运行时修改，运行结束后失效。
		2.设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。
		设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。

运算符：
	1.算数运算符：
		**    幂运算
		//    向下取整
	2.逻辑运算符：
		and（&&） 
		or（||）
		not（！）
	3.比较运算符：
		<>    不等于
	4.成员运算符：
		in        如果在指定的序列中找到值返回 True，否则返回 False
		not in    如果在指定的序列中没有找到值返回 True，否则返回 False
	5.身份运算符
		is        判断两个标识符是不是引用自一个对象,即地址是否相同，相同返回True
		is not    地址不同返回True
		
	[注]整数比较中的坑：1.Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，
					   在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。
					   Python把频繁使用的整数对象的值定在[-5, 256]这个区间，如果需要这个范围的整数，就直接从small_ints中获取引用而不是临时创建新的对象
							def fun1():																def fun1():
								d = 256																d = 257
								e = 256																e = 257
								d += 1																print(d is e)
								e += 1																if(d is e):
								if(d is e):																print("%d is %d"%(d,e))
									print("%d is %d"%(d,e))											else:
								else:																	print("%d is not %d"%(d,e))
									print("%d is not %d"%(d,e)) 									-----------------------------------
							-----------------------------------------                         		-----------------------------------
							-----------------------------------------									257 is 257
									257 is not 257
									
					   2.Python内部为了进一步提高性能，凡是在“一个代码块中”创建的整数对象（全局不优化），如果值不在small_ints缓存范围之内，
						但在同一个代码块中已经存在一个值与其相同的整数对象了，那么就直接引用该对象，否则创建一个新的对象出来
						
						a = 257
						b = 257
						a is b    #False   未优化
						
						def fun1():
							d = 257
							e = 257
							print(d is e)    #True  优化
						参考：https://blog.csdn.net/jackfrued/article/details/79521404 
