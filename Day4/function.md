## 函数
### 定义<br>
  def　函数名称（）：<br>
      缩进块内是函数体<br>
### 参数
* 形式参数<br>
		调用时分配内存单元，调用结束释放<br>
* 实际参数<br>
		可以是常量，变量，表达式，函数<br>
* 默认参数<br>
		默认参数的值在编译阶段就绑定的<br>
		必须是不变对象（元组，字符串，数字，None）<br>
			原因：如默认参数为可变对象L[]，第一次调用函数时，函数内部改变了L内存中的值，那么第二次调用时，L的值就变了，和函数看起来的功能不一样<br>
			例子：<br>
  ```
   def f(L=[]):
      L.append(‘a’)
   return L
   print(L)  #a<
   print(L)  #aa
   ```
* 可变参数<br>
		定义时：形式参数前加*,说明要输入的是可变的<br>
		调用时：如果输入列表元组，前面加* 。<br>
  ```
  def sum(*num):
    sums = 0 
    for x in num:
      sums += x
    return sums
  ```
  ```
  sum(1,2,3)
  sum(*(1,2,3),1,2,3)
  ```
* 关键字参数<br>
		允许用户在调用函数时，添加额外的形式参数及它的值，可以不填<br>
		定义时：形式参数前加**<br>
		调用时：新的形参名=值<br>
				   若使用字典来对应这个关键字参数，则字典前加**<br>
		在参数列表中新加入的参数与值，其实在函数中变成了一个名为‘关键字参数’的字典<br>
* 命名关键字参数<br>
		限定‘关键字参数’的名字，没有缺省值则必须填，但顺序不限<br>
		定义时：在参数列表中，采用*分隔，*后面的是限定名字的关键字参数<br>
		调用时：在参数列表中，限定参数名 = 值<br>
* 组合参数<br>
		各种参数有顺序要求：形式参数，默认参数，可变参数，命名关键词参数，关键词参数<br>
		位置型参数位置必须对应，关键词形参数位置不限，但要写出参数名<br>
### 作用域<br>
* python中作用域是静态的，即变量名被赋予的地方决定了这个变量的作用域
* 高级语言对数据类型的使用过程<br>
      一般的高级语言在使用变量时，都会有下面4个过程。当然在不同的语言中也会有着区别。<br>
      1.声明变量：让编辑器知道有这一个变量的存在<br>
      2.定义变量：为不同数据类型的变量分配内存空间<br>
      3.初始化：赋值，填充分配好的内存空间<br>
      4.引用：通过引用对象(变量名)来调用内存对象(内存数据)<br>
* 在Python中，使用一个变量时并不严格要求需要预先声明它，但是在真正使用它之前，它必须被绑定到某个内存对象(被定义、赋值)<br>
* 作用域的类型<br>
      局部作用域L：在函数内定义的变量拥有局部作用域，在该函数体内可以访问<br>
      嵌套作用域E：python允许在函数中定义函数，因此，对子函数而言，自己内部为局部作用域，子外部，父内部为嵌套作用域<br>
      全局作用域G：一般是模块层次定义的变量，仅限于单个模块文件内<br>
      内置作用域B：系统里固定模块内定义的变量<br>
* 搜索变量名的优先级<br>
      LEGB
  ```
  variable = 300
  def test_scopt():
  print variable   #variable是test_scopt()的局部变量，但是在打印时并没有绑定内存对象。触发的错误是UnboundLocalError而不是NameError：name ‘variable’ is not defined
  variable = 200   #因为这里，所以variable就变为了局部变量
  test_scopt()
  print variable
  ```
>Python虽然是一个静态作用域语言，但变量名查找是动态发生的，直到在程序运行时，才会发现作用域方面的问题
 ### 返回值
* return只能返回一个对象，这个对象内可以包含多个值，比如返回列表，元组
    

